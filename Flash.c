/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : Flash.c
**     Project   : Project
**     Processor : MC9S12XEP100MAG
**     Component : IntFLASH
**     Version   : Component 02.367, Driver 02.17, CPU db: 3.00.036
**     Compiler  : CodeWarrior HCS12X C Compiler
**     Date/Time : 2016/8/14, 15:02
**     Abstract  :
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
**     Settings  :
**         Total FLASH memory size       : 1024KB
**         Number of FLASH memory blocks : 5
**           Sector size                 : 0x0400
**         Interrupt service             : Disabled
**         Write method                  : Safe write (with save & erase)
**         Buffer Type                   : Implemented by the component
**         Wait in RAM                   : yes
**     Contents  :
**         SetProtection - byte Flash_SetProtection(bool ProtectType, byte ProtectHigh, byte ProtectLow,...
**         SetByteFlash  - byte Flash_SetByteFlash(Flash_TAddress Addr, byte Data);
**         SetWordFlash  - byte Flash_SetWordFlash(Flash_TAddress Addr, word Data);
**         DataPtr2Addr  - Flash_TAddress Flash_DataPtr2Addr(void* Addr);
**         FuncPtr2Addr  - Flash_TAddress Flash_FuncPtr2Addr(void(*Addr)());
**
**     Copyright : 1997 - 2011 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/


/* MODULE Flash. */

#include "Flash.h"

#pragma DATA_SEG Flash_DATA            /* Select data segment "Flash_DATA" */
#pragma CODE_SEG Flash_CODE

/*lint -save  -e923 -e926 -e927 -e928 -e929 Disable MISRA rule (11.3,11.4) checking. */
#pragma MESSAGE DISABLE C12056         /* Disable warning C12056 "SP debug info incorrect becouse of optimization or inline assembler" */

/* Types definitions */

typedef struct {
   uint8_t code[15];             /* Structure required to copy code to ram memory */
  /* Size of this structure needs to be at least (but best) the size of the FnCmdInRam_ */
} FnCmdInRamStruct;

typedef void (* near pFnCmdInRam)(void);

/* Global variables */

static word BackupArray[0x0200U];      /* Array for backup data from erased sector */


#pragma CODE_SEG __NEAR_SEG NON_BANKED

static void FnCmdInRam_(void)
{
  FSTAT = 0x80U;                       /* Clear flag command buffer empty */
  while (FSTAT_CCIF == 0U) {}          /* Wait to command complete */
  return;
}

#pragma MESSAGE DISABLE C1805          /* Disable warning C1805 "Non-standard conversion used" */
/*lint -save  -e740 -e931 Disable MISRA rule (1.2) checking. */
static void CallFnCmdInRam()
{
  FnCmdInRamStruct FnCmdInRam = *(FnCmdInRamStruct *)(FnCmdInRam_); /* Create a copy of Wait in RAM routine on stack */

  ((pFnCmdInRam)&FnCmdInRam)();        /* Call code in RAM */
  return;
}
/*lint -restore Enable MISRA rule (1.2) checking. */
#pragma MESSAGE WARNING C1805          /* Enable warning C1805 "Non-standard conversion used" */

#pragma CODE_SEG Flash_CODE

#pragma MESSAGE DISABLE C4001 /* Disable warning C4001: Condition always FALSE */
/*
** ===================================================================
**     Method      :  BlockOutOfRange (component IntFLASH)
**
**     Description :
**         The method checks if selected block is present in the flash 
**         module.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define BlockOutOfRange(Addr1, Addr2) ((Addr1 > Addr2) || (Addr2 > 0x007FFFFFUL) || (Addr1 < 0x00700000UL))

/*
** ===================================================================
**     Method      :  ClearFlags (component IntFLASH)
**
**     Description :
**         The method clear error flags of Flash module.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define ClearFlags()  (FSTAT = 0x30U)


/*
** ===================================================================
**     Method      :  WriteWord (component IntFLASH)
**
**     Description :
**         The method writes a word to the Flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteWord(Flash_TAddress Addr,word Data16)
{
  byte err = 0U;
  dword PhraseAddr;                    /* Address of a phrase (8-byte alligned) */
  byte diff;

  EnterCritical();                     /* Enter critical section */
  ClearFlags();                        /* Clear all flags */
  if (FSTAT_CCIF == 0U) {              /* Is command buffer full ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_BUSY;                   /* If yes then error */
  }
  FCCOBIX = 0U;                        /* Clear index register */
  FCCOBHI = 0x06U;                     /* Program P-Flash command */
  FCCOBLO = (byte)(Addr >> 16U);       /* High address word */
  FCCOBIX++;                           /* Shift index register */
  PhraseAddr = Addr & 0xFFFFFFF8UL;    /* Phrase is aligned to 8 bytes */
  FCCOB = (word)(PhraseAddr);          /* Low address word */
  diff = (byte)(Addr & 0x07U);         /* difference between address and phrase */
  for(err = 0U;err < 8U;err += 2U) {
    FCCOBIX++;                         /* Shift index register */
    if(err == diff) {                  /* Is address equal to Addr ? */
      FCCOB = Data16;                  /* Load new data */
    } else {
      FCCOB = *((word *far)(PhraseAddr + err)); /* Load previously stored data */
    }
  }
  CallFnCmdInRam();                    /* Copy Wait in RAM routine to stack and launch the flash process */
  if (FSTAT_FPVIOL == 1U) {            /* Is protection violation detected ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  if (FSTAT_ACCERR == 1U) {            /* Is acces error detected ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  if (FSTAT_MGSTAT) {                  /* Was attempt to write data to the given address errorneous? */
    ExitCritical();                    /* Exit critical section */
    return ERR_VALUE;                  /* If yes then error */
  }
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}
/*
** ===================================================================
**     Method      :  BackupSector (component IntFLASH)
**
**     Description :
**         The method backups the content of a sector being erased.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(Flash_TAddress Addr, word From, word To)
{
  word i;

  for (i = From; i < To; i += 2U) {
    BackupArray[i / 2U] = *(word *far) (Addr + i); /* save one sector to RAM */
  }
}

/*
** ===================================================================
**     Method      :  RestoreSector (component IntFLASH)
**
**     Description :
**         The method restores the content of a sector after erase.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte RestoreSector(Flash_TAddress Addr, word From, word To)
{
  byte err = 0U;
  word i;
  dword PhraseAddr;                    /* Address of a phrase (8-byte alligned) */
  byte j;

  EnterCritical();                     /* Enter critical section */
  ClearFlags();                        /* Clear all flags */
  PhraseAddr = Addr & 0xFFFFFFF8UL;    /* Phrase is aligned to 8 bytes */
  i = From;
  while(i < To) {
    FCCOBIX = 0U;                      /* Clear index register */
    FCCOBHI = 0x06U;                   /* Program P-Flash command */
    FCCOBLO = (byte)(PhraseAddr >> 16U); /* High address word */
    FCCOBIX++;                         /* Shift index register */
    FCCOB = (word)(PhraseAddr);        /* Low address word */
    for(j = 0U;j < 8U;j += 2U) {
      FCCOBIX++;                       /* Shift index register */
      FCCOB = BackupArray[i/2U];       /* Load new data */
      i += 2U;
    }
    CallFnCmdInRam();                  /* Copy Wait in RAM routine to stack and launch the flash process */
    if (FSTAT_FPVIOL == 1U) {          /* Is protection violation detected ? */
      ExitCritical();                  /* Exit critical section */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if (FSTAT_ACCERR == 1U) {          /* Is acces error detected ? */
      ExitCritical();                  /* Exit critical section */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if (FSTAT_MGSTAT) {                /* Was attempt to write data to the given address errorneous? */
      err = 1U;                        /* If yes then mark an error */
    }
    PhraseAddr += 8U;
  }
  if(err != 0U) {
    ExitCritical();                    /* Exit critical section */
    return ERR_VALUE;                  /* If yes then error */
  }
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EraseSectorInternal (component IntFLASH)
**
**     Description :
**         The method erase a specific sector.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte EraseSectorInternal(Flash_TAddress Addr)
{

  EnterCritical();                     /* Enter critical section */
  ClearFlags();                        /* Clear all flags */
  if (FSTAT_CCIF == 0U) {              /* Is command complete ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_BUSY;                   /* If yes then error */
  }
  FCCOBIX = 0U;                        /* Clear index register */
  FCCOBHI = 0x0AU;                     /* Erase P-Flash sector command */
  FCCOBLO = (byte)(Addr >> 16U);       /* High address word */
  FCCOBIX++;                           /* Shift index register */
  FCCOB = (word)(Addr & 0xFFFFFFF8UL); /* Low address word aligned to 8 byte phrase*/
  CallFnCmdInRam();                    /* Copy Wait in RAM routine to stack and launch the flash process */
  if (FSTAT_FPVIOL == 1U) {            /* Is protection violation detected ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  if (FSTAT_ACCERR == 1U) {            /* Is acces error detected ? */
    ExitCritical();                    /* Exit critical section */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}
/*
** ===================================================================
**     Method      :  Flash_SetProtection (component IntFLASH)
**
**     Description :
**         Method allows write to protection register. Please see
**         Flash Block User Guide.
**     Parameters  :
**         NAME            - DESCRIPTION
**         ProtectType     - Possible values: 0 or 1.
**                           Depend on CPU type. Two sense are
**                           possible.
**                           First:
**                           - 0 = whole Flash array is protected. In
**                           this case other parameters are don't
**                           care.
**                           - 1 = protection size depend on
**                           ProtectHigh and ProtectLow parameters.
**                           Second:
**                           - 0 = ProtectHigh and ProtectLow
**                           parameters define range to by protected .
**                           - 1 = ProtectHigh and ProtectLow
**                           parameters define range to by
**                           unprotected .
**         ProtectHigh     - Flash higher address
**                           range protection. Possible values:
**                           - 0 - 3 - defines range (size of range
**                           depend on CPU type) , 4 - Protection
**                           disabled
**         ProtectLow      - Flash lower address
**                           range protection. Possible values:
**                           - 0 - 3 - defines range (size of range
**                           depend on CPU type) , 4 - Protection
**                           disabled
**         Block           - Flash block number. Number of
**                           blocks depend on CPU type. If CPU has
**                           only one block, the value is don't care.
**     Returns     :
**         ---             - Error code, possible codes:
**                           - ERR_OK - OK
**                           - ERR_NOTAVAIL - Requested value not
**                           operation is not available
**                           - ERR_RANGE - Value is out of range
**                           - ERR_VALUE - Parameter of incorrect
**                           value
**                           - ERR_SPEED - This device does not work
**                           in the active speed mode
** ===================================================================
*/
byte Flash_SetProtection_(bool ProtectType,byte ProtectHigh,byte ProtectLow)
{
  byte TempFPROT;

  if ((ProtectHigh > 4U)||(ProtectLow > 4U)||(ProtectType > 1U)) { /* Range check */
    return ERR_RANGE;
  }
  TempFPROT = ((byte)(ProtectType << 7U)) | ((byte)(ProtectHigh << 3U)) | ProtectLow; /* Set temoraly variable */
  if((TempFPROT & 0x24U) != 0x24U) {   /* Is FPHDIS or FPLDIS cleared ? */
    FPROT = TempFPROT | 0x24U ;        /* Set protection with FPHDIS and FPLDIS set first */
  }
  FPROT = TempFPROT;                   /* Set new protection */
  if ((FPROT & 0xBFU) != (TempFPROT & 0xBFU)) {
    return ERR_VALUE;                  /* Was protection register set corectly? */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Flash_SetByteFlash (component IntFLASH)
**
**     Description :
**         Write byte to address in FLASH.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to FLASH.
**         Data            - Data to write.
**     Returns     :
**         ---             - Error code, possible codes:
**                           - ERR_OK - OK
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available
**                           - ERR_RANGE - Address is out of range
**                           - ERR_VALUE - Read value is not equal to
**                           written value
**                           - ERR_SPEED - This device does not work
**                           in the active speed mode
** ===================================================================
*/
byte Flash_SetByteFlash(Flash_TAddress Addr,byte Data)
{
  word Data16;                         /* Temporaly variable */
  byte err;
  byte NeedErase;
  dword PhraseAddr;

  if (BlockOutOfRange(Addr, Addr)) {   /* Check range of address */
    return(ERR_RANGE);
  }
  if (FSTAT_CCIF == 0U) {              /* Is previous command complete ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  NeedErase = 0U;
  PhraseAddr = Addr & 0xFFFFFFF8UL;    /* Get Phrase address (8 byte aligned) */
  for (err = 0U;err < 8U;err += 2U) {  /* Check burned area is erased */
    if(*(word *far) (PhraseAddr + err) != 0xFFFFU) {
      NeedErase = 1U;
      break;
    }
  }
  if (NeedErase) {
    BackupSector(Addr & 0x00FFFC00UL, 0U, 0x0400U); /* Backup sector */
    err = EraseSectorInternal(Addr & 0x00FFFFFEUL); /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    Data16 = BackupArray[(Addr % 0x0400U) / 2U];
    if (Addr & 1U) {
      Data16 = (Data16 & 0xFF00U) | Data; /* Not Aligned word ? */
    } else {
      Data16 = ((word)Data << 8U) | (Data16 & 0xFFU);
    }
    BackupArray[(Addr % 0x0400U) / 2U] = Data16; /* Write new data to saved sector */
    err = RestoreSector(Addr & 0x00FFFC00UL, 0U, 0x0400U); /* Restore sector */
  }
  else {
    if (Addr & 1U) {                   /* Not Aligned word ? */
      err = WriteWord(Addr & 0x00FFFFFEUL, ((*(word *far)(Addr & 0x00FFFFFEUL)) & 0xFF00U) | Data);
    } else {
      err = WriteWord(Addr, ((word)Data << 8U) | (*(byte *far)(Addr + 1U))); /* Aligned word ? */
    }
  }
  return(err);                         /* Return error code if previous operation finished not correctly */
}

/*
** ===================================================================
**     Method      :  Flash_SetWordFlash (component IntFLASH)
**
**     Description :
**         Write word to address in FLASH.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to FLASH.
**         Data            - Data to write.
**     Returns     :
**         ---             - Error code, possible codes:
**                           - ERR_OK - OK
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available
**                           - ERR_RANGE - Address is out of range
**                           - ERR_VALUE - Read value is not equal to
**                           written value
**                           - ERR_SPEED - This device does not work
**                           in the active speed mode
** ===================================================================
*/
byte Flash_SetWordFlash(Flash_TAddress Addr,word Data)
{
  byte err;
  byte NeedErase;
  dword PhraseAddr;

  if (BlockOutOfRange(Addr, (Addr + 1U))) { /* Check range of address */
    return(ERR_RANGE);
  }
  if ((Addr & 1U) != 0U) {             /* Aligned address ? */
    return ERR_NOTAVAIL;
  }
  if (FSTAT_CCIF == 0U) {              /* Is previous command complete ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  NeedErase = 0U;
  PhraseAddr = Addr & 0xFFFFFFF8UL;    /* Get Phrase address (8 byte aligned) */
  for (err = 0U;err < 8U;err += 2U) {  /* Check burned area is erased */
    if(*(word *far) (PhraseAddr + err) != 0xFFFFU) {
      NeedErase = 1U;
      break;
    }
  }
  if (NeedErase) {
    BackupSector(Addr & 0x00FFFC00UL, 0U, 0x0400U); /* Backup sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    BackupArray[(Addr % 0x0400U) / 2U] = Data; /* Write new data to saved sector */
    err = RestoreSector(Addr & 0x00FFFC00UL, 0U, 0x0400U); /* Restore sector */
  }
  else {
    err = WriteWord(Addr, Data);       /* Write new data to Flash */
  }
  return(err);                         /* Return error */
}

/*
** ===================================================================
**     Method      :  Flash_DataPtr2Addr (component IntFLASH)
**
**     Description :
**         This method converts data pointer to format of a component's
**         method address parameter. Generally a data pointer format is
**         different from format of a method Addr parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Addr            - Data pointer.
**     Returns     :
**         ---             - Address in the format used in the
**                           component methods.
** ===================================================================
*/
Flash_TAddress Flash_DataPtr2Addr(const void *far Addr)
{
  return((Flash_TAddress)((const void *far)Addr));
}

#pragma MESSAGE DISABLE C1860 /* Disable warning C1860: Pointer conversion - possible loss of data */

/*
** ===================================================================
**     Method      :  Flash_FuncPtr2Addr (component IntFLASH)
**
**     Description :
**         This method converts function pointer to format of a
**         component's method address parameter. Generally a function
**         pointer format is different from format of a method Addr
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Addr            - Function pointer.
**     Returns     :
**         ---             - Address in the format used in the
**                           component methods.
** ===================================================================
*/
Flash_TAddress Flash_FuncPtr2Addr(void(*far Addr)())
{
  if((((dword)Addr) > 0xFFFFUL)&&(((dword)Addr & 0xFFU) != 0U)){ /* Is address banked ? */
    return((((Flash_TAddress)Addr & 0xFFU) << 14U) + (((Flash_TAddress)Addr & 0x003FFF00UL) >> 8U) + 0x00400000UL);
  } else {
    if(((dword)Addr) > 0xFFFFUL){      /* if bank==0 ? */
      Addr = (void(*far)())((dword)Addr >> 8U); /* Discard bank info */
    }
    return((Flash_TAddress)Addr + 0x007F0000UL);
  }
}

/*
** ===================================================================
**     Method      :  Flash_Init (component IntFLASH)
**
**     Description :
**         Initializes the associated peripheral(s) and the component 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void Flash_Init(void)
{
  FCLKDIV = 0x0FU;                     /* Set up Clock Divider Register */
}


/*lint -restore Enable MISRA rule (11.3,11.4) checking. */

/* END Flash. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.05 [04.46]
**     for the Freescale HCS12X series of microcontrollers.
**
** ###################################################################
*/
